##  散列表

数组利用二分查找时间复杂度为 O(logN)，我们可以利用一种特别的函数，该函数接收被查询对象就可以得到该对象在数组中应该被存储的位置，这样时间复杂度可以降低为 O(1)。

这种函数被称为哈希函数。他需要完成下面工作：
1. 传入相同的 key，计算出来的 index 应该相同
2. 传入不同的 key，计算出来的 idex 不相同
3. 计算的 index 应该均匀分布
4. 高性能


###  哈希冲突
但要找到需要同时具备上面所有特点的哈希函数十分困难，哈希函数难免会对两个不同对象计算出相同 index，这种情况被称为**哈希冲突**。

对于散列表的使用，我们不希望哈希冲突影响我们对数据的存储。**装载因子**用来衡量哈希冲突的程度，
```
装载因子 = 当前数据量 / 数组长度
```
解决哈希冲突的方法有两个：
1. 开放寻址法：即当前对象计算出来的 index 已经被其他对象占用，这时候可以根据不同策略进行处理。
    * 线性探测：步长为 1 找到下一个空位置
    * 二次探测：步长为 2 的幂次方找到下一个空位置
    * 多长散列：使用另一个哈希函数计算新的位置
当对象被删除时，标记为 Deleted，目的是保证后面的数据可悲探测。
2. 拉链法：让数据额外维护一个 next 指针，当出现哈希冲突时使用 next 指针找到目标对象。

两者的应用场景：
1. 开放寻址适用于装载因子小的情况，节省空间。
2. 拉链需要额外维护一个指针，链表本身对缓存不友好，而且当链表较长时需要自动转换成 AVL 或红黑树，适用于装载因子较大的场景。

无论怎么样，哈希表总有不够用的时候，特别是开放寻址方式。所以哈希表扩容需要 rehash，这是一个非常耗时的工作，rehash 应该均摊到后续的操作上。

### 哈希函数应用场景
哈希函数被运用在下面几个场景：
1. 散列表中的散列函数
2. 数据加密（但不能解密）：登录密码保存，为了防止数据库被脱裤后黑客使用字典集猜出密码，一般要使用 salt 与密码一起加密
3. 唯一标识：可以作为文件、对象的唯一标识，不过还是有可能冲突
4. 数据校验：下载文件后查看文件是否完整，比如 BT 种子
5. 负载均衡
6. 数据分片和分布式存储：在数据量比较大的时候，可以将数据切片放到不同的机器上存储，当用户需要查询时对用户输入进行 hash 就能够直到数据存放在哪个节点上。为了提高拓展性，一般会使用一致性哈希（哈希环）决定哪些数据保存在哪个节点上


###  模板和技巧

1. 利用语言特性判断 key 是否相等：
哈希表在题目上一般都是用来换时间的，散列表的 key 可以根据语言特性做取巧。比如 Go 的数组是可以比较的，对于题目 
- ****[242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)****
- ****[49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)****
需要额外注意语言中 char 的字节数

2. LRU Cache
Java 中的 LinkedHashMap 通过链表 + 散列表实现 LRU 淘汰。我们自己实现的时候千万不要用库提供的链表，因为 LRU 的两个核心方法：
* 删除某个节点
* 删除链表第一个元素
* 删除链表最后一个元素 （可有和第一点合并）

为了高效删除某个节点，使用双向链表 + 散列表（直接散列到删除节点上，用双向指针删除当前节点）比较高效。

[Java 实现](LRUCache.java)

###  

